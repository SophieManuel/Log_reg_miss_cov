---
title: "Simu_3cov"
author: "Laurent Llinares"
date: "27/11/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(misaem)
library(MASS)
library(mvtnorm)
library(mice)
library(ggplot2)
library(RColorBrewer)
library(tidyr)
theme_set(theme_bw())
```

# 3 covariables & 10% manquants

initialisation du jeu de données avec 3 covariables et 10% de valeur manquante
```{r}
#n <- 10000  # number of subjects
n <- 500 # or a smaller number of subjects 
p <- 3     # number of explanatory variables
mu.star <- 1:p  # mean of the explanatory variables
sd <- 1:p # standard deviations

 
# without correlation
C = diag(p)

Sigma.star <- diag(sd)%*%C%*%diag(sd) # variance-covariance matrix of the explanatory variables
beta.star <- c(0.5, -0.3, 1) # coefficients of logistic regression
beta0.star <- -0.2  # intercept
beta.true = c(beta0.star,beta.star)
#percentage of missingness
p.miss <- 0.10 
patterns = runif(n*p)<p.miss
```

## MCAR

algo pour MCAR et 10% d'erreur
```{r}
deb=Sys.time()
nbsim = 50
EST.saem = EST.comp = EST.cc = matrix(0, 2*nbsim,length(beta.star)+2)

for (NB in 1:nbsim){
  set.seed(NB)
  #print(NB)
  # complete data simulation
  X.complete <- matrix(rnorm(n*p), nrow=n)%*%chol(Sigma.star) + matrix(rep(mu.star,n), nrow=n, byrow = TRUE)
  p1 <- 1/(1+exp(-X.complete%*%beta.star-beta0.star))
  y <- as.numeric(runif(n)<p1)
  
  # ----- No NA : classical estimation in the case without missingness
  data.complete <- data.frame(y=y,X.complete)
  model.complete <- glm(y ~.,family=binomial(link='logit'),data=data.complete)
  beta0.complete <- model.complete$coefficients[1]
  beta.complete <- model.complete$coefficients[2:(p+1)]
  P <- predict(model.complete, type = "response")
  W <- diag(P*(1-P))
  X <- model.matrix(model.complete)
  V_complete <- solve(t(X)%*%W%*%X)
  std.complete <- sqrt(diag(V_complete))
  
  # generating missing data - MCAR missingness
  X.obs <- X.complete
  patterns = runif(n*p)<p.miss
  X.obs[patterns] <- NA
  X.obs<-data.frame(X.obs)
  
  # ------- CC : estimation ignoring the missing data
  data.obs <- data.frame(y=y,X.obs)
  model.obs <- glm(y ~.,family=binomial(link='logit'),data=data.obs)
  beta0.cc <- model.obs$coefficients[1]
  beta.cc <- model.obs$coefficients[2:(p+1)]
  P <- predict(model.obs, type = "response")
  W <- diag(P*(1-P))
  X <- model.matrix(model.obs)
  V_cc <- solve(t(X)%*%W%*%X)
  std.cc <- sqrt(diag(V_cc))
  
 # -------  SAEM
  list.saem=miss.glm(y~.,data=as.data.frame(X.obs), print_iter=FALSE,var_cal=TRUE)
  beta.saem = list.saem$coefficients
  std.saem = list.saem$s.err
  
  EST.comp[NB,] = c(beta0.complete,beta.complete, "MCAR")
  EST.cc[NB,] = c(beta0.cc,beta.cc, "MCAR")
  EST.saem[NB,] = c(beta.saem, "MCAR")


}
Sys.time()-deb
```



## MAR

Estimation des poids de la combinaison linéaire non-unique par la méthode de MC en tâtonnant.
```{r}
simMC <- 1000
vect <- NULL
gam0 <- c(2,2)
for (nMC in 1:simMC)
{
  X.complete <- matrix(rnorm(n*p), nrow=n)%*%chol(Sigma.star) + matrix(rep(mu.star,n), nrow=n, byrow = TRUE)
  p1 <- 1/(1+exp(-X.complete%*%beta.star-beta0.star))
  y <- as.numeric(runif(n)<p1)
  
  # generating missing data - MAR missingness
   X.obs <- X.complete
   for(i in c(1,3)){
     z <- cbind(y,X.complete[,2])%*%matrix(gam0,ncol=1) # linear combination 
     pr <- 1/(1+exp(-z))         # pass through an inv-logit function
     r <- rbinom(n,1,pr)      # bernoulli response variable
     X.obs[r==0,i]<-NA
   }
   vect[nMC]<- mean(is.na(X.obs[,i]))
} 

E_MC <- mean(vect)
sd_MC <- sd(vect)
IC_U <- E_MC + 1.96 * sd_MC/sqrt(simMC)
IC_L <- E_MC - 1.96 * sd_MC/sqrt(simMC)

cat('percentage of NA for MC : ', E_MC, 'with confidence interval 95 % of : [',IC_L, ', ', IC_U ,'] with gamma_0 = ', gam0,'\n')
```


algo pour MAR et 10% d'erreur
```{r}
deb = Sys.time()
nbsim = 50
STD.saem = STD.comp = STD.cc = matrix(0, nbsim,length(beta.true))
LENGTH.saem = LENGTH.comp = LENGTH.cc = matrix(0, nbsim,length(beta.true))
count.saem = count.comp = count.cc  = rep(0,p+1)

for (NB in 1:nbsim){
  set.seed(NB)
  #print(NB)
  # complete data simulation
  X.complete <- matrix(rnorm(n*p), nrow=n)%*%chol(Sigma.star) + matrix(rep(mu.star,n), nrow=n, byrow = TRUE)
  p1 <- 1/(1+exp(-X.complete%*%beta.star-beta0.star))
  y <- as.numeric(runif(n)<p1)
  
  # ----- No NA : classical estimation in the case without missingness
  data.complete <- data.frame(y=y,X.complete)
  model.complete <- glm(y ~.,family=binomial(link='logit'),data=data.complete)
  beta0.complete <- model.complete$coefficients[1]
  beta.complete <- model.complete$coefficients[2:(p+1)]
  P <- predict(model.complete, type = "response")
  W <- diag(P*(1-P))
  X <- model.matrix(model.complete)
  V_complete <- solve(t(X)%*%W%*%X)
  std.complete <- sqrt(diag(V_complete))
  
 # generating missing data - MAR missingness
 X.obs <- X.complete
   X.obs<-data.frame(X.obs)

  for(i in c(1,3)){
   z <- cbind(y,X.complete[,2])%*%matrix(gam0,ncol=1) # linear combination #(coefficients choosen with Monte Carlo estimation)
  pr <- 1/(1+exp(-z))         # pass through an inv-logit function
   r <- rbinom(n,1,pr)      # bernoulli response variable
   X.obs[r==0,i]<-NA
  }
  
  # ------- CC : estimation ignoring the missing data
  data.obs <- data.frame(y=y,X.obs)
  model.obs <- glm(y ~.,family=binomial(link='logit'),data=data.obs)
  beta0.cc <- model.obs$coefficients[1]
  beta.cc <- model.obs$coefficients[2:(p+1)]
  P <- predict(model.obs, type = "response")
  W <- diag(P*(1-P))
  X <- model.matrix(model.obs)
  V_cc <- solve(t(X)%*%W%*%X)
  std.cc <- sqrt(diag(V_cc))
  
 # -------  SAEM
  list.saem=miss.glm(y~.,data=X.obs, print_iter=FALSE,var_cal=TRUE)
  beta.saem = list.saem$coefficients
  std.saem = list.saem$s.err
  
  EST.comp[NB+nbsim,] = c(beta0.complete,beta.complete, "MAR")
  EST.cc[NB+nbsim,] = c(beta0.cc,beta.cc, "MAR")
  EST.saem[NB+nbsim,] = c(beta.saem, "MAR")


}
Sys.time()-deb
```


```{r}
dfbeta1_3_sscorr_10pecent <- data.frame("Estimateur"= as.numeric(c(EST.comp[,3], EST.cc[,3], EST.saem[,3])), "Méthode" = as.factor( c(rep("complet",nbsim*2), rep("cc",nbsim*2), rep("saem",nbsim*2))), "alea"= as.factor(c(EST.comp[,p+2],EST.cc[,p+2],EST.saem[,p+2]))) # dernière colonne du tableau pour créer l'indicatrice MCAR/MAR
dfbeta1_3_sscorr_10percent <- dfbeta1_3_sscorr_10pecent[dfbeta1_3_sscorr_10pecent[,1]!=0,]
```

boxplots esthétiques comparaison MCAR/MAR pour comp, cc et saem, $10\%$ valeurs manquantes $n=500$
```{r}
box <- ggplot(dfbeta1_3_sscorr_10percent, aes(x=Méthode,y=Estimateur)) + geom_boxplot(aes(fill=alea))
box <- box + geom_hline(yintercept=-0.3, linetype="dashed", color = "purple", size=1)
box <- box + ggtitle(expression(paste("Boxplots de l'estimation de ",beta[2]," avec 3 covariables")))
#box <- box + ggtitle(paste(expression("Boxplots de l'estimation de ",beta[1])," en fonction \ndu type d'aléatoire et des méthodes d'estimation sans corrélation\n  échantillon ",n, "avec",p, "variables et ",p.miss*100,"% de valeurs manquantes" )  )
box + theme(plot.title = element_text(hjust = 0.5))
```



#  3 covariables & 10% manquant avec corrélation

initialisation du jeu de données avec 3 covariables et 10% de valeur manquante
```{r}
#n <- 10000  # number of subjects
n <- 500 # or a smaller number of subjects 
p <- 3     # number of explanatory variables
mu.star <- 1:p  # mean of the explanatory variables
sd <- 1:p # standard deviations

C <- cbind(c(1,0.8,0.5),c(0.8,1,0.3),c(0.5,0.3,1))  # correlation matrix

Sigma.star <- diag(sd)%*%C%*%diag(sd)
beta.star <- c(0.5, -0.3, 1) # coefficients of logistic regression
beta0.star <- -0.2  # intercept
beta.true = c(beta0.star,beta.star)
#percentage of missingness
p.miss <- 0.10 
patterns = runif(n*p)<p.miss
```

## MCAR

algo pour MCAR et 10% d'erreur
```{r}
deb = Sys.time()
nbsim = 50
EST.saem = EST.comp = EST.cc = matrix(0, 2*nbsim,length(beta.star)+2)

for (NB in 1:nbsim){
  set.seed(NB)
  #print(NB)
  # complete data simulation
  X.complete <- matrix(rnorm(n*p), nrow=n)%*%chol(Sigma.star) + matrix(rep(mu.star,n), nrow=n, byrow = TRUE)
  p1 <- 1/(1+exp(-X.complete%*%beta.star-beta0.star))
  y <- as.numeric(runif(n)<p1)
  
  # ----- No NA : classical estimation in the case without missingness
  data.complete <- data.frame(y=y,X.complete)
  model.complete <- glm(y ~.,family=binomial(link='logit'),data=data.complete)
  beta0.complete <- model.complete$coefficients[1]
  beta.complete <- model.complete$coefficients[2:(p+1)]
  P <- predict(model.complete, type = "response")
  W <- diag(P*(1-P))
  X <- model.matrix(model.complete)
  V_complete <- solve(t(X)%*%W%*%X)
  std.complete <- sqrt(diag(V_complete))
  
  # generating missing data - MCAR missingness
  X.obs <- X.complete
  patterns = runif(n*p)<p.miss
  X.obs[patterns] <- NA
  X.obs<-data.frame(X.obs)
  
  # ------- CC : estimation ignoring the missing data
  data.obs <- data.frame(y=y,X.obs)
  model.obs <- glm(y ~.,family=binomial(link='logit'),data=data.obs)
  beta0.cc <- model.obs$coefficients[1]
  beta.cc <- model.obs$coefficients[2:(p+1)]
  P <- predict(model.obs, type = "response")
  W <- diag(P*(1-P))
  X <- model.matrix(model.obs)
  V_cc <- solve(t(X)%*%W%*%X)
  std.cc <- sqrt(diag(V_cc))
  
 # -------  SAEM
  list.saem=miss.glm(y~.,data=X.obs, print_iter=FALSE,var_cal=TRUE)
  beta.saem = list.saem$coefficients
  std.saem = list.saem$s.err
  
  EST.comp[NB,] = c(beta0.complete,beta.complete, "MCAR")
  EST.cc[NB,] = c(beta0.cc,beta.cc, "MCAR")
  EST.saem[NB,] = c(beta.saem, "MCAR")


}
Sys.time()-deb
```



## MAR

Estimation des poids de la combinaison linéaire non-unique par la méthode de MC en tatonnant.
```{r}
simMC <- 1000
vect <- NULL
gam0 <- c(2,2)
for (nMC in 1:simMC)
{
  X.complete <- matrix(rnorm(n*p), nrow=n)%*%chol(Sigma.star) + matrix(rep(mu.star,n), nrow=n, byrow = TRUE)
  p1 <- 1/(1+exp(-X.complete%*%beta.star-beta0.star))
  y <- as.numeric(runif(n)<p1)
  
  # generating missing data - MAR missingness
   X.obs <- X.complete
   for(i in 2){
     z <- cbind(y,X.complete[,2])%*%matrix(gam0,ncol=1) # linear combination 
     pr <- 1/(1+exp(-z))         # pass through an inv-logit function
     r <- rbinom(n,1,pr)      # bernoulli response variable
     X.obs[r==0,i]<-NA
   }
   vect[nMC]<- mean(is.na(X.obs[,i]))
} 

E_MC <- mean(vect)
sd_MC <- sd(vect)
IC_U <- E_MC + 1.96 * sd_MC/sqrt(simMC)
IC_L <- E_MC - 1.96 * sd_MC/sqrt(simMC)

cat('percentage of NA for MC : ', E_MC, 'with confidence interval 95 % of : [',IC_L, ', ', IC_U ,'] with gamma_0 = ', gam0,'\n')
```


algo pour MAR et 10% d'erreur
```{r}
deb=Sys.time()
nbsim = 50
STD.saem = STD.comp = STD.cc = matrix(0, nbsim,length(beta.true))
LENGTH.saem = LENGTH.comp = LENGTH.cc = matrix(0, nbsim,length(beta.true))
count.saem = count.comp = count.cc  = rep(0,p+1)

for (NB in 1:nbsim){
  set.seed(NB)
  #print(NB)
  # complete data simulation
  X.complete <- matrix(rnorm(n*p), nrow=n)%*%chol(Sigma.star) + matrix(rep(mu.star,n), nrow=n, byrow = TRUE)
  p1 <- 1/(1+exp(-X.complete%*%beta.star-beta0.star))
  y <- as.numeric(runif(n)<p1)
  
  # ----- No NA : classical estimation in the case without missingness
  data.complete <- data.frame(y=y,X.complete)
  model.complete <- glm(y ~.,family=binomial(link='logit'),data=data.complete)
  beta0.complete <- model.complete$coefficients[1]
  beta.complete <- model.complete$coefficients[2:(p+1)]
  P <- predict(model.complete, type = "response")
  W <- diag(P*(1-P))
  X <- model.matrix(model.complete)
  V_complete <- solve(t(X)%*%W%*%X)
  std.complete <- sqrt(diag(V_complete))
  
 # generating missing data - MAR missingness
 X.obs <- X.complete
   X.obs<-data.frame(X.obs)

  for(i in c(1,3)){
   z <- cbind(y,X.complete[,2])%*%matrix(gam0,ncol=1) # linear combination #(coefficients choosen with Monte Carlo estimation)
  pr <- 1/(1+exp(-z))         # pass through an inv-logit function
   r <- rbinom(n,1,pr)      # bernoulli response variable
   X.obs[r==0,i]<-NA
  }
  
  # ------- CC : estimation ignoring the missing data
  data.obs <- data.frame(y=y,X.obs)
  model.obs <- glm(y ~.,family=binomial(link='logit'),data=data.obs)
  beta0.cc <- model.obs$coefficients[1]
  beta.cc <- model.obs$coefficients[2:(p+1)]
  P <- predict(model.obs, type = "response")
  W <- diag(P*(1-P))
  X <- model.matrix(model.obs)
  V_cc <- solve(t(X)%*%W%*%X)
  std.cc <- sqrt(diag(V_cc))
  
 # -------  SAEM
  list.saem=miss.glm(y~.,data=X.obs, print_iter=FALSE,var_cal=TRUE)
  beta.saem = list.saem$coefficients
  std.saem = list.saem$s.err
  
  EST.comp[NB+nbsim,] = c(beta0.complete,beta.complete, "MAR")
  EST.cc[NB+nbsim,] = c(beta0.cc,beta.cc, "MAR")
  EST.saem[NB+nbsim,] = c(beta.saem, "MAR")


}
Sys.time()-deb
```



```{r}
dfbeta1 <- data.frame("Estimateur"= c(EST.comp[,2], EST.cc[,2], EST.saem[,2]), "meth" = as.factor( c(rep("comp",nbsim*2), rep("cc",nbsim*2), rep("saem",nbsim*2))), "alea"= as.factor(c(EST.comp[,p+2],EST.cc[,p+2],EST.saem[,p+2]))) # dernière colonne du tableau pour créer l'indicatrice MCAR/MAR
```

boxplots esthétiques comparaison MCAR/MAR pour comp, cc et saem, 10% valeurs manquantes n=500
```{r}
box <- ggplot(dfbeta1, aes(x=meth,y=as.numeric(Estimateur))) + geom_boxplot(aes(fill=alea))
box <- box + ggtitle(paste("Boxplots de l'estimation en fonction \ndu type d'aléatoire et des méthodes d'estimation avec corrélation\n  échantillon  ",n, "avec",p, "variables  un ",p.miss,"  missing"  ) )
box + theme(plot.title = element_text(hjust = 0.5))
```

